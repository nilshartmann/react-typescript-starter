<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>React Workshop</title>

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/github.css">
  <style>
    /*pre code {*/

    /*display: block;*/

    /*padding: 0.5em;*/

    /*background: #FFFFFF !important;*/

    /*color: #000000 !important;*/

    /*}*/

    .right-img {
      margin-left: 10px !important;
      float: right;
      height: 500px;
    }

    .todo:before {
      content: 'TODO: ';
    }

    .todo {
      color: red !important;
    }

    code span.line-number {
      color: lightcoral;
    }

    .reveal pre {
      max-width: 980px;
    }

    .reveal pre code {
      max-height: 1000px !important;
    }

    .reveal section img {
      border: 0;
      box-shadow: 0 0 0 0
    }

    /*rgb(196, 215, 240)*/

    html.exkurs body {
      background: rgb(252, 220, 185) url("ai/es6-icon.png") no-repeat right bottom;
    }
  </style>

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>


<body>

  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

      <section id="t5">
        <h2>React mit TypeScript entwickeln</h2>
        <h3>Themen</h3>
        <ul>
          <li>
            <a href="#/t5a">TypeScript Grundlagen</a>
          </li>
          <li>
            <a href="#/t5b">React-Anwendungen mit TypeScript entwickeln</a>
          </li>
        </ul>
      </section>

      <section id="t5a">
        <h2>Hintergrund: TypeScript</h2>
        <p>
          <em>TypeScript is a superset of JavaScript that compiles to plain JavaScript </em>(
          <a href="http://www.typescriptlang.org/" target="_blank">http://www.typescriptlang.org/</a>)</p>
        <ul>
          <li>Erweitert JavaScript um ein Typen System</li>
          <li>Jeder gültige JavaScript Code ist auch gültiger TypeScript Code</li>
          <li>Mittels des TypeScript Compilers wird aus TS Code JavaScript Code</li>
          <li>Entwickelt von Microsoft</li>
          <li>Unterstützung in vielen IDEs (z.B. Anzeige von Fehlern, Refactoring, ...) </li>
        </ul>
      </section>

      <section>
        <h3>Wichtige Unterschiede zu Java/C#</h3>
        <ul>
          <li>Typ-Informationen sind nach dem compilieren weg (keine Reflection API etc)
            <ul>
              <li>Das gilt auch für Sichtbarkeiten und readonly Felder</li>
            </ul>
          </li>
          <li>Es wird auch JavaScript-Code erzeugt, selbst wenn es einen Compile-Fehler gibt</li>
          <li>Im Gegensatz zu Java/C# sind bei TypeScript zwei Typen kompatibel, sofern sie
            <b>dieselbe Struktur</b> haben</em>
          </li>
        </ul>
      </section>

      <section>
        <h3>TypeScript Grundlagen</h3>
        <p>Typ-Angaben werden hinter einen Bezeichner geschrieben</p>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Variablen können Typ-Informationen bekommen
let foo: string;
foo = 'yo';
// Error: number: This type is incompatible with string
foo = 10;
               </code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Funktionen
function sayIt(what: string): string {
  return `Saying: ${what}`;
}

sayIt('Klaus'); // ok
sayIt(10); // error
</code></pre>


        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Arrow Funktionen
const sayIt = (what: string): string => `Saying: ${what}`;

sayIt('Moin');
sayIt(123); // Error: Argument of type '123' is not assignable
            // to parameter of type 'string'.
</code></pre>
      </section>

      <section>
        <h2>Eingebaute Typen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// string
let city: string = 'Hamburg';

// boolean
let isDone: boolean = false;

// number
let theAnswer: number = 42;

// array (note the [])
let cities: string[] = ['Hamburg', 'Barcelona'];
// alternative:
let languages: Array&lt;string> = ['JavaScript', 'TypeScript'];

// any
let theUnknown: any = 'Who cares';
theUnknown = 666; // ok
theUnknown = true; // ok
let a: number = theUnknown; // ok

// void
function log(s: string): void { /* ... */ }
            </code></pre>

      </section>
      <section>
        <h2>Typen können abgeleitet (inferred) werden</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
let city = 'Hamburg'; // city ist ein String

city = 42;
// Fehler: [ts] Type '42' is not assignable to type 'string'.
</code></pre>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
// Explizite Angabe eines Types (parameter)
// und abgeleiteter Typ (Return Type der Funktion)

function sayIt(what: string) {
  return `Saying: ${what}`;
}

const said: string = sayIt('Hello TypeScript'); // ok
const saidItWrong: number = sayIt('Hello TypeScript'); // error!


</code></pre>
      </section>
      <section>
        <h2>Strict Mode</h2>
        <ul>
          <li>
            <b>strict</b>: seit TypeScript 2.3</li>
          <li>Shortcut u.a. für:
            <ul>
              <li>
                <b>noImplicitAny</b>:
                <code>any</code> muss explizit hingeschrieben werden</li>
              <li>
                <b>strictNullChecks</b>: Null muss explizit erlaubt werden (z.B. bei Rückgabewerten)</li>
            </ul>
          </li>
          <li>Empfehlung: für neue Projekte einschalten, sonst Schrittweise</li>
        </ul>
        <p>
          <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a>
        </p>
      </section>
      <section>
        <h2>Type Check ausschalten</h2>
        <p>Mit
          <code>@ts-ignore</code> (als Kommentar) kann wird die Überprüfung der nächsten Zeile ausgeschaltet:</p>
        <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = "Hamburg";

city = 20259; // error: [ts] Type '20259' is not assignable to type 'string'.

// @ts-ignore
city = 20259; // ok                
</code></pre>
        <p class="fragment">Nützlich in corner cases, die nur schwer mit TypeScript abbildbar sind oder bei Migration</p>
      </section>
      <section>
        <h2>null und undefined</h2>
        <div class="fragment">
          <p>
            <code>null</code> muss explizit zugelassen werden
            <em>(strictNullChecks</em>):</p>
          <pre><code class="typescript line-numbers" contenteditable data-trim>
let city:string = null; //Type 'null' is not assignable to type 'string'.

let optionalCity:string|null = null; // OK
            </code></pre>
        </div>
        <div class="fragment">
          <p>Optionale Parameter können mit ? gekennzeichnet werden (erlauben dann auch
            <code>undefined</code>)</p>
          <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
function greet(name: string, greeting?: string) {
  console.log(`${greeting || 'Hello'}, {name}`);
}

greet('Susi', 'Moin')// Moin, Susi

// 2. Parameter ist optional:
greet('Klaus'); // Hello, Klaus

greet('Peter', null); // Argument of type 'null' is not assignable
                      // to parameter of type 'string | undefined'.
            </code></pre>
        </div>
      </section>


      <section>
        <h2>Klassen</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  what: string; // Typ-Angabe für Felder ist erforderlich

  constructor(what: string) { // Typ-Angabe für Parameter ist erforderlich
    this.what = what;
  }

  // Angabe des Return-Types optional
  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

</code></pre>
      </section>

      <section>
        <h2>Klassen (Sichtbarkeiten)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // Erlaubte Sichtbarkeiten: private | protected | public
  private what: string; 

  constructor(what: string) { 
    this.what = what;
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}

const sayer = new Sayer("Susi");
sayer.what = ""; // ERROR: Property 'greeting' is private

</code></pre>
      </section>
      <section>
        <h2>Klassen (Parameter Properties)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {
  // identisch zu vorherigem Beispiel
  constructor(private what: string) {
  }

  sayIt(): string {
    return `Saying: ${this.what}`;
  }
}
</code></pre>
      </section>
      <section>
        <h2>Klassen (readonly Felder)</h2>
        <pre class="fragment"><code class="typescript line-numbers" contenteditable data-trim>
class Sayer {

  readonly what: string; 

  // Alternativ:
  constructor(readonly public what: string) {
  }

  setWhat(newWhat: string) {
    this.what = newWhat; // ERR Cannot assign to 'what' 
                         // because it is a read-only property.
  }
}
</code></pre>
      </section>
      <section>
        <h2>Eigene Typen</h2>
        <p>Mit
          <code>interface</code> können eigene Typen defniert werden:</p>

        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// Komplexer Typ
interface Person {
	name: string; // Pflicht
	livesIn?: string; // Optional
}

const susi: Person = { // OK
	name: 'Klaus',
	livesIn: 'Hamburg'
};
const klaus: Person = { // OK (livesIn ist optional)
	name: 'Klaus'
}

const helmut: Person = {} // Error: Property 'name' is missing

const lukas: Person = {
	name: 'Lukas',
	profession: 'Lokführer'
} // Error: 'profession' does not exist in type 'Person'.
               </code></pre>

      </section>

      <section>
        <h2>Typ Kompatibilität</h2>
        <em>Im Gegensatz zu Java/C# ("nominal typing") sind bei TypeScript zwei Typen kompatibel, sofern sie
          <b>dieselbe Struktur</b> haben ("structural typing")</em>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Book {
	title: string
}

interface Movie {
	title: string
}

const book:Book = { title: "Das Kapital" };
const movie:Movie = book; // OK, obwohl Book !== Movie
               </code></pre>
      </section>
      <section>
        <h2>Generics</h2>
        <p>Generische Typen verwenden</p>
        <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Person { name: string };
interface Movie { title: string };

let persons:Array&lt;Person&gt; = [];
let movies:Array&lt;Movie&gt; = [];

persons.push({name: 'Klaus'});
movies.push({title: 'Batman'});

persons.push({title: 'Casablanca'}) // error ('title' not in Person)

persons = movies; // error

      </code></pre>
      </section>
      <section>
        <h2>Arbeiten mit externen Bibliotheken</h2>
        <p>Typings installieren und verwenden</p>
        <ul>
          <li>Typings sind optional, können aber über zusätzliches Deklarations-File hinzugefügt werden
            <li>Typings für Kern-Bibliotheken kommen mit TypeScript Compiler
              <li>Manche Bibliotheken werden bereits mit TypeScript Deklarations-Files ausgeliefert (z.B. Redux)
                <li>Typen können über
                  <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/" target="_blank">npm</a> installiert werden und sind dann ohne weiter Schritte nutzbar (z.B.
                  <em>npm install @types/react --save</em>)
        </ul>
      </section>

      <section>
        <h2>Arbeiten mit externen Bibliotheken</h2>
        <p>Typings selber beschreiben</p>
        <ul>
          <li>Workaround, wenn keine Typings vorhanden sind

            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
declare module 'jquery';

declare module 'module-with-default-export' {
  let str: string;
  export default str;
}
                          </code></pre>
          </li>
        </ul>
      </section>

      <section id="t5b">
        <h2>React Anwendungen mit TypeScript</h2>
        <em>State und Properties von Komponenten werden mit Typen beschrieben</em>
      </section>
      <section>
        <h2>Voraussetzungen</h2>
        <ul>
          <li class="fragment">React Type Deklarationen installieren:
            <pre><code data-trim contenteditable class="line-numbers bash" data-leftpad>
npm install --save @types/react @types/react-dom
        </code></pre>
          </li>
          <li class="fragment">(Externe) Module, die kein Default-Export haben, müssen mit
            <code>import *</code> importiert werden:
            <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// JavaScript/Babel:
import React from 'react';

// TypeScript
import * as React from 'react';
        </code></pre>
          </li>
          <li class="fragment">Dateien, die JSX-Code enthalten, müssen mit
            <code>.tsx</code> enden</li>
          <li class="fragment">Compiliert wird mit TypeScript (statt Babel). Integration in Webpack mit
            <a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank">
              <code>awesome-typescript-loader</code>
            </a>
          </li>
        </ul>
      </section>
      <section>
        <h2>Getypte React Komponenten</h2>
        <p>
          <code>React.Component</code> ist eine generische Klasse, die einen Typ für Properties und State erwartet</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
interface Greeting = {name: string; greeting: string};

interface GreetingDetailProps {
    greeting?: Greeting;
    onSave: (newGreeting: NewGreeting) => void;
}

interface GreetingDetailState {
    name: string;
    greeting: string;
}
            </code></pre>

        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>

class GreetingDetail
  extends React.Component&lt;GreetingDetailProps, GreetingDetailState> {
  // ...
}
            </code></pre>
      </section>
      <section>
        <h3>Typsicherheit in React Komponenten</h3>
        <p>Properties und State sind typsicher</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
constructor(props: Props) {
    super(props);

    this.state = { name: '', greeting: ''} // OK

    // ERROR: Object literal may only specify known properties,
    // and 'aha' does not exist in type 'Readonly&lt;State>'
    this.state = {name: '', greeting: '', aha: 10};

    // ERROR: Cannot assign to 'greeting' because
    // it is a constant or a read-only property.
    this.state.greeting = 'no way';
}

render() {
  // ERROR: Property 'nothere' does not exist on type...
  return &lt;div>{this.props.nothere}&lt;/iv>;
}
               </code></pre>
      </section>
      <section>
        <h2>React Events in TypeScript</h2>
        <span class="fragment">
          <pre><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
class GreetingDetail extends React.Component&lt;Props, State> {
  // . . .
  updateModel(event: React.SyntheticEvent&lt;HTMLInputElement>) {
    // 'currentTarget' anstatt 'target' verwenden:
    const { name, value } = event.currentTarget;
    // . . .

    // Compile error! 
    this.setState({[name]}: value);

    // typechecking ausschalten
    this.setState({[name as any]: value});

    // @ts-ignore (alternative, seit TS 2.6)
    this.setState({[name]}: value);
  }
}

        </code></pre>
          <p>
            <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682" target="_blank">
              <code>target</code> vs
              <code>currentTarget</code>
            </a>
          </p>
        </span>

      </section>
      <section>
        <h2>Functional Components</h2>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
type GreetingMasterProps = {
    greetings: Greeting[]
    onAdd: () => void
};
        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
const GreetingMaster = (props: GreetingMasterProps) => {
    const {greetings, onAdd} = props;
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster = ({greetings, onAdd}: GreetingMasterProps) => {
    // . . .
}

        </code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers typescript" data-leftpad>
// or
const GreetingMaster: React.SFC&lt;GreetingMasterProps> = props => {
    const {greetings, onAdd} = props;
    // . . .
}
        </code></pre>
      </section>
      <section>
        <h2>Übung: Eine Komponente auf TypeScript umstellen</h2>
        <h3>
          <em>Stelle die GreetingDetail Komponente auf TypeScript um</em>
        </h3>
        <div style="font-size: 80%">
          <p>
            <b>Hinweis: </b> Bitte arbeite dazu in dem neuen Workspace
            <code>code/workspace-typescript</code>:</p>
          <ul>
            <li>Dieses Verzeichnis enthält die Anwendung aus unserem letzten Schritt, aber in TypeScript implementiert</li>
            <li>Lediglich das
              <code>GreetingDetail</code> ist noch in JavaScript implementiert</li>
            <li>Du kannst den Webpack Server in diesem Verzeichnis ebenfalls mit
              <code>npm start</code> starten</li>
            <li>Denk dran, deinen laufenden Webpack Server vorher zu beenden</li>
          </ul>
        </div>
      </section>
      <section>
        <h2>Schritte</h2>
        <ol style="font-size:80%">
          <li>Definiere einen Typen für die Properties und den State und passe die
            <code>GreetingDetail</code>-Klasse an</li>
          <li>Füge der Komponente das
            <code>input</code>-Property hinzu (Type:
            <code>HTMLInputElement</code>)</li>
          <li>Experimentiere (optional):
            <ul>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> auf ein nicht bekanntes Property zugreifst?</li>
              <li>Was passiert, wenn Du im
                <code>GreetingDetail</code> den State mit
                <code>this.state = { . . .}</code> neu setzt?</code>
              </li>
              <li>Was passiert, wenn Du beim Aufrufen des
                <code>GreetingDetail</code> (
                <code>GreetingController</code>) ein zusätzliches Property übergibst?</li>
            </ul>
          </li>
        </ol>
      </section>


      <section id="t6">
        <h1>Teil VI</h1>
        <h2>Client-seitiges Routing (Überblick)</h2>
        <a href="code/schritte/router-v4-typescript/public/index.html" target="_blank">Ziel-Anwendung</a>
      </section>
      <section>
        <h2>Warum Routing?</h2>
        <span>
          <p>Mappen von URLs auf Komponenten
            <br>
            <span style="font-size: 80%">(Navigation findet ohne Server-Roundtrip statt)</span>
          </p>
        </span>
        <span>
          <p>Komponenten halten (Teil) des Zustandes der Anwendung
            <br>
            <span style="font-size: 80%">Welche Komponente ist sichtbar (Master oder Detail)?</span>
            <br>
            <span style="font-size: 80%">Welche Daten werden dafür geladen (z.B. Greeting Id)</span>
          </p>
        </span>
      </section>

      <section>
        <h2>Herausforderungen</h2>
        <p>Auf Änderungen der URL reagieren
          <br>
          <span style="font-size: 80%">Ableiten des Zustandes aus der URL
            <br>Wenn sich die URL ändert, kein Server roundtrip</span>
        </p>
        <p>Hierarchische Komponentenstrukturen</p>
        <p>Beim Klick auf Links etc aktualisieren der URL</p>
      </section>

      <section>
        <h2>React Router</h2>
        <ul>
          <li>Kein Bestandteil von React</li>
          <li>Sehr häufig verwendet (de-facto Standard)</li>
          <li>Aktuelle Version 4:
            <a href="https://reacttraining.com/react-router/" target="_blank">
              https://reacttraining.com/react-router/</a>
          </li>
        </ul>
      </section>
      <section>
        <h3>Das Router-Objekt</h3>
        <p class="fragment">Top-Level-Objekt, das einmalig (oben) in der Komponenten Hierarchie eingebunden werden muss</p>
        <p class="fragment">Mehrere Ausprägungen zum Arbeiten mit den URL und der Browser History:
          <ul>
            <li class="fragment">
              <b>HashRouter</b>: codiert Pfad in angehängten Hash (#/greetings)</li>
            <li class="fragment">
              <b>BrowserRouter</b>: codiert Pfad direkt in URL (/greetings)</li>
          </ul>
        </p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router} from "react-router-dom";

const app = &lt;Router>&lt;GreetingController/>&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
        </code></pre>
      </section>

      <section>
        <h3>Welche Komponente soll für einen Pfad gerendert werden</h3>
        <p class="fragment">Das
          <code>Route</code>-Objekt mappt Pfade auf Komponenten</p>
        <ul>
          <li class="fragment">
            Wird verwendet, wo Pfad-abhängig Komponenten ausgewählt werden sollen
            <ul>
              <li>vergleichbar mit intelligentem
                <code>if</code>/
                <code>switch</code> statement</li>
              <li>Kann überall in der Anwendung</b> verwendet werden (auf allen Hierarchie-Ebenenen) </li>
            </ul>
          </li>
          <li class="fragment">Mit
            <code>path</code> wird der Pfad übergeben, für den die Route matchen soll</li>
          <li class="fragment">Mit
            <code>component</code> wird die Komponente übergeben</li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route} from "react-router-dom";

const app = &lt;Router>
  &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
  &lt;Route path="/" component={GreetingController}/>
&lt;/Router>;

ReactDOM.render(app, document.getElementById(...));
        </code></pre>
      </section>
      <section>
        <h3>Route #2: Das render-Property</h3>
        <ul>
          <li>Statt einer Komponente kann eine Funktion übergeben werden, die eine Komponente zurückliefert</li>
          <li>Ermöglicht es, zusätzliche Properties an die Komponente zu übergeben</li>
          <li>Kann unterschiedliche Komponenten zurückliefern (z.B. für Authorisierung) </li>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/"
  render={() => {
    return loggedIn ? 
      &lt;GreetingMaster greetings={initialGreetings} />
    :
      &lt;LoginForm />
  }}
/>
        </code></pre>
        </ul>
      </section>
      <section>
        <h3>Hintergrund: Pfade</h3>
        <p>In Routen werden
          <b>Pfade</b> angegeben, die mit der aktuellen URL verglichen werden</b>
          <ul>
            <li>Pfade sind per Default gültig für Teilstrings</li>
            <li>Mit
              <code>exact</code> kann das Verhalten verändert werden
              <li>Eine Route ohne
                <code>path</code> matcht immer</li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// trifft zu für / und /greeting
&lt;Route path="/" component={GreetingController}/>

// trifft nur zu für /
&lt;Route path="/" exact component={GreetingController}/>

// passt auf jede URL:
&lt;Route component={GreetingController}/>

        </code></pre>
          <ul>
            <li class="fragment">Kann variable Segmente enthalten:
            </li>
          </ul>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
&lt;Route path="/greeting/:greetingId"
      component={&lt;GreetingDisplay />} />

// in GreetingDisplay kann die greetingId über
// this.props.match.params.greetingId abgefragt werden
        </code></pre>


      </section>
      <section>
        <h3>Switch</h3>
        <ul>
          <li class="fragment">Wenn mehrere path-Ausdrücke matchen, werden mehrere Komponenten gerendert (z.B. "/" und "/greetings")</li>
          <li class="fragment">
            <code>Switch</code> sorgt dafür, dass nur die erste Komponente im Block gerendert wird</li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {HashRouter as Router, Route, Switch} from "react-router-dom";

const app = (
  &lt;Router>
    &lt;Switch>
      &lt;Route path="/greet/:greetingId" component={GreetingDisplayController}/>
      &lt;Route path="/" component={GreetingController}/>

      // "No match": ohne Pfad
      &lt;Route component={NotFoundPage}/>

    &lt;/Switch>
  &lt;/Router>
);

ReactDOM.render(app, document.getElementById(...));
        </code></pre>
      </section>

      <section>
        <h3>Router Properties für Komponente</h3>
        <p>Der Router übergibt automatisch drei Properties an die gerenderte Komponente:</p>
        <ul>
          <li class="fragment">
            <code>match</code>: Enthält u.a. die Parameter aus dem Pfad (
            <code>match.params.xyz</code>)</li>
          <li class="fragment">
            <code>history</code>: Zum Arbeiten mit der History (z.B.
            <code>push()</code> zum Navigieren)</li>
          <li class="fragment">
            <code>location</code>: Der aktuelle Pfad (z.B.
            <code>pathname</code>,
            <code>search</code>)</li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
const HelloComponent = ({match, history, location}) => (
  &lt;div>
    &lt;h1>Hello, {match.params.name}&lt;/h1>
    &lt;small>The current path is: {location.pathname}&lt;/small>
    &lt;button onClick={() =&gt; history.push('/greetings')}>Show Greetings&lt;/button>
  &lt;/div>
);

// ...
&lt;Route path="/greet/:name" component={HelloComponent}/>

        </code></pre>
        <ul>
          <li class="fragment">Die Properties werden auch an die
            <code>render</code>-Funktion einer
            <code>Route</code> als Parameter übergeben
          </li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
 &lt;Route path="/somewhere" render={({match, history, location}) => . . . }/>
          
                  </code></pre>
      </section>

      <section>
        <h3>Links</h3>
        <p>Mit
          <code>Link</code> und
          <code>NavLink</code> können Links erzeugt werden</p>
        <ul>
          <li>Mit
            <code>to</code> wird das Ziel angegeben</li>
          <li>Gerendert wird per default ein
            <code>a</code> Element</li>
          <li>URL wird entsprechend der History (Browser oder Hash) erzeugt</li>
          <li>Mit
            <code>activeClassName</code> und
            <code>activeStyle</code> auf
            <code>NavLink</code> können Styles übergeben werden, die angewendet werden, wenn der Link der aktiven Route entspricht
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {Link, NavLink} from "react-router-dom";

&lt;Link to='/greetings'>Show all greetings&lt;/Link>

// Erzeugtes 'a' Element erhält 'highlight' CSS-Klasse, wenn die aktive Route
&lt;NavLink to='/greeting/me' activeClassName="highlight">Greet me&lt;/NavLink>

        </code></pre>
      </section>

      <section>
        <h3>Das history-Objekt</h3>
        <p class="fragment">Mit dem
          <code>history</code>-Objekt kann mit der Browser History interagiert werden</p>
        <p class="fragment">Es gibt verschiende Implementierungen (insb BrowserHistory und HashHistory sowie "memory history" für Testen)</p>
        <p class="fragment">Mit der History kann auf andere URLs gesprungen werden oder die Location abgefragt werden</p>
        <p class="fragment">Route-Komponenten erhalten die history automatisch per Property</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
function GreetingController({history}) {
  // gehe zu neuer URL
  history.push("/..."); 

  // gehe zu neuer URL, lösche aber aktuelle aus History im Browser
  history.replace("/...") 

  // aktuelle URL
  const currentPath = history.location.pathname; 
}
        </code></pre>
      </section>

      </section>

      <section>
        <h3>Zugriff auf die history außerhalb von "Route Components"</h3>
        <ul>
          <li class="fragment">Komponenten, die von
            <code>Route</code> gerendert werden, erhalten automatisch Zugriff auf
            <code>history</code> etc</li>
          <li class="fragment">Für alle anderen Komponenten, brauchen wir eine andere Lösung</li>
          <li class="fragment">
            <code>withRouter</code> HOC "erweitert" Komponenten und Router Properties</li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import {withRouter} from "react-router-dom";

function GreetLink(props) {
  const greeting = this.props.greeting; // übergeben vom ursprünglichen Aufrufer
  const history = this.props.history; // übergeben von withRouter
  return &lt;div>
    &lt;button onClick={() =&gt; history.push(`/${greeting.id}`)}>Show Greeting&lt;/button>
  &lt;/div>;
}

// 
export default withRouter(GreetingLink);
                  </code></pre>
      </section>
      <section>
        <h3>withRouter zur Laufzeit</h3>
        <img src="./images/screenshot-withRouter.png" />
      </section>

      <section>
        <h3>Hintergrund</h3>
        <h2>Higher-Order Components (HOC)</h2>
        <p>https://reactjs.org/docs/higher-order-components.html</p>
        <p>Eine Higher-Order Komponente ist eine Funktion, die
          <b>eine Komponente entgegennimmt und eine neue Komponente zurückliefert</b>
        </p>
        <p class="fragment">Die Higher-Order-Kommponente ist für das
          <b>rendern</b> der ursprünglichen Komonente verantwortlich
          <ul class="fragment">
            <li>Sie kann das Rendern bei Bedarf auch unterdrücken oder verzögern</li>
            <li>Sie hat Zugriff auf alle ursprünglichen Properties</li>
            <li>Sie kann der Ziel-Komponente zusätzliche Properties übergeben oder welche entfernen</li>
          </ul>
        </p>

      </section>
      <section>
        <h3>Beispiel: Higher-Order Components (HOC)</h3>
        <p>Ziel:
          <em>Eine HOC, die ein Greeting lädt das geladene Greeting an die ursprüngliche Komponente weitergibt</em>
        </p>
        <div style="font-size:85%">
          <p>Vorteile:
            <ul>
              <li>"Komplexe" Logik zum Laden der Daten, Fehlerbehandlung etc, liegt zentral in der HOC</li>
              <li>Die gewrappte Komponente muss sich nicht um das (technische) Laden kümmern</li>
              <li>Die gewrappte Komponente benötigt keinen Lifecycle, sie wird nur dargestellt, wenn ein Greeting vorhanden ist</li>
            </ul>
          </p>
        </div>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  
// GreetingDisplayController.js          
// GreetingDisplayController (stellt einen Gruß dar):
function GreetingDisplayController({greeting}) {
  return &lt;h1>&lt;{greeting.name}, {greeting.greeting}&lt;/h1>;
}
  
// umschliessen mit der HOC
export default withGreeting(GreetingDisplayContainer);
</code></pre>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// Verwender
import GreetingDisplayController from "...";
// dass es sich um eine HOC handelt, ist für den Verwender transparent:
&lt;GreetingDisplayController greetingId={3} />
                                  </code></pre>
      </section>
      <section>
        <h3>Beispiel: Higher-Order Components (HOC)</h2>
          <p>Schritt 1: HOC definieren</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  
  // Schritt 1: stumpfes Wrappen einer Komponente.
  function withGreeting(RawComponent) {
    return class extends React.Component {
      render() {
        // mit {...this.props} werden alle Properties, die der HOC übergeben
        // wurden,  an die Ziel-Komponente übergeben
        return &lt;RawComponent {...this.props} />
      }
    }
                                  </code></pre>
      </section>
      <section>
        <h3>Beispiel: Higher-Order Components (HOC)</h2>
          <p>Schritt 2: Lifecycle-Methoden ("fachliche" Logik der HOC) implementieren</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
function withGreeting(RawComponent) {
  return class extends React.Component {
  
    // HOC ist "normale" Komponente, dh wir habe Lifecycle-Methoden etc
    componentDidMount() {
      // GreetingId kommt aus den Props, mit dem die HOC aufgerufen wurde
      const greeting = loadGreeting(this.props.greetingId);
      this.setState({greeting});
    }

    componentWillReceiveProps(nextProps) {
      // analog: greeting lesen und State setzen
    }
  
    render() { . . . }
  }
}
                                    </code></pre>
      </section>
      <section>
        <h3>Beispiel: Higher-Order Components (HOC)</h2>
          <p>Schritt 3: Implementieren der render-Methode</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  function withGreeting(RawComponent) {
    return class extends React.Component {
    
      componentDidMount() { ... }
  
      componentWillReceiveProps(nextProps) { ... }
        // analog: greeting lesen und State setzen
      }
    
      render() { 
        if (!this.state.greeting) {
          // Greeting noch nicht geladen
          return null;  
          // alternativ: Loading Spinner zeigen, Fehlerbehandlung o.ä.
        }

        // Ziel-Komponente erhält geladenes Greeting als
        // 'greeting' Property
        return &lt;RawComponent greeting={this.state.greeting} />
      }
    }
  }
                                      </code></pre>
      </section>
      <section>
        <h3>Beispiel: Higher-Order Components (HOC)</h2>
          <p>Schritt 4: Verwenden der HOC</p>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import withGreeting from ". . .";

// GreetingDisplayController kennt kein greetingId-Property, 
// nur das geladene Greeting
function GreetingDisplayController({greeting}) { . . .};

export default withGreeting(GreetingDisplayController);
                                        </code></pre>
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import GreetingDisplayController from ". . .";

// Verwender übergibt nur das greetingId-Property, 
// nicht das geladene Greeting
&lt;GreetingDisplayController greetingId={7} />
                                        </code></pre>
      </section>
      <section>
        <h2>Alternative PropTypes</h2>
        <p>https://reactjs.org/docs/render-props.html</p>
        <p>https://www.youtube.com/watch?v=BcVAq3YFiuc</p>
      </section>

      <section>
        <h2>Der Router mit TypeScript</h2>
      </section>

      <section>
        <h3>RouteComponentProps</h3>
        <p>Der Router übergibt Properties an eine Route-Komponente</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
// GreetingController erhält history etc als Property          
&lt;Route component={GreetingController} />
                                                    </code></pre>
        <p class="fragment">Die Route-Properties sind im Interface
          <code>RouteComponentProps</code> definiert</p>
        <p class="fragment">Die Komponente kann für ihre Properties das Interface erweitern:</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import { RouteComponentProps } from "react-router";
interface GreetingControllerProps extends RouteComponentProps&lt;void&gt { 
  // ggf. eigene Properties des GreetingControllers
}
class GreetingController extends React.Component&lt;GreetingControllerProps> {
  render() {
    const history = this.props.history; // ok, kein Compile-Fehler
  }
}
</code></pre>
      </section>
      <section>
        <h3>RouteComponentProps #2</h3>
        <p>Der Router übergibt die Parameter aus der URL an die Route-Komponente</p>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  // GreetingController erhält "greetingId" als Property
  &lt;Route path="/greeting/:greetingId" component={GreetingController} />
                                                      </code></pre>
        <p class="fragment">RouteComponentProps ist mit den erwarteten Parametern aus der URL generifiziert
          <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
import { RouteComponentProps } from "react-router";

// Die im Path definierten Parameter
interface GreetingControllerParams { greetingId: string };

// Als Type-Argument werden die Parameter angegeben
interface GreetingControllerProps extends 
  RouteComponentProps&lt;GreetingControllerParams&gt {   }

class GreetingController extends React.Component&lt;GreetingControllerProps> {
  render() {
    const params = this.props.match;

    const greetingId = params.greetingId; // ok, kein Compile-Fehler
    const userId = params.userId; // Fehler: userId nicht bekannt
  }
}
  </code></pre>
      </section>

      <section id="t7">
        <h1>Teil VII</h1>
        <h2>Ausblick / Diskussion / Offene Punkte</h2>
        <ul style="font-size: 85%">
          <li>
            <a href="#/t7th">Thinking in React - Links</a>
          </li>
          <li>Architekturpattern: Flux / Redux</li>
          <li>Modularisierung von React Anwendungen</li>
          <li>
            <a href="#/t7a">Komponentenbibliotheken und Formularframeworks</a>
          </li>
          <li>
            <a href="#/t7b">Bibliotheken für Internationalisierung</a>
          </li>
          <li>
            <a href="#/t7c">Projektstruktur</a>
          </li>
          <li>
            <a href="#/t7d">Einbinden von 3rd-Party-Libs (am Beispiel jQuery)</a>
          </li>
        </ul>
      </section>

      <section id="t7th">
        <h3>Thinking in React - Links</h3>
        <ul>
          <li>
            <a href="https://reactjs.org/docs/thinking-in-react.html" target="_blank">Thinking in React (Doku)</a>
          </li>
          <li>
            <a href="https://dev.to/dan_abramov/react-beginner-question-thread--1i5e" target="_blank">React Beginner Question Thread von/mit Dan Abramov</a>
          </li>
          <li>
            <a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" target="_blank">You might not need Redux</a>
          </li>
          <li>
            <a href="https://twitter.com/dan_abramov/status/931333632572252160" target="_blank">"Is this what real-world reactjs code looks like?"😉</a>
          </li>
        </ul>
      </section>

      <section id="t7a">
        <h3>Komponentenbibliotheken und Formularframeworks</h3>
        <ul>
          <li>
            <a href="https://gist.github.com/nilshartmann/decb10d37a76ae3ab58f0c7755beb038" _target="blank">Meine Auswahl</a>
          </li>
          <li>
            <a href="https://reactjs.org/community/ui-components.html" _target="blank">Liste von reactjs.org</a>
          </li>
        </ul>
      </section>

      <section id="t7b">
        <h3>Internationalisierung</h3>
        <ul>
          <li>
            <a href="https://github.com/yahoo/react-intl" _target="blank">react-intl von Yahoo</a>
          </li>
          <li>
            <a href="https://react.i18next.com/" target="_blank">i18next</a>
          </li>
          <li>
            <a href="https://github.com/lingui/js-lingui" _target="blank">Einfachere(?) Lösung: js-lingui</a>
          </li>
        </ul>
      </section>

      <section id="t7c">
        <h3>Projektstruktur</h3>
        <ul>
          <li>
            <a href="https://medium.freecodecamp.org/8-key-react-component-decisions-cc965db11594" target="_blank">8 Key React Component Decisions (mit vielen Links!)</a>
          </li>
          <li>
            <a href="https://hackernoon.com/the-100-correct-way-to-structure-a-react-app-or-why-theres-no-such-thing-3ede534ef1ed" target="_blank">The 100% correct way to structure a React app (or why there’s no such thing)</a>
          </li>
          <li>
            <a href="*  https://medium.com/styled-components/component-folder-pattern-ee42df37ec68" target="_blank">Writing Scalable React Apps with the Component Folder Pattern</a>
          </li>
        </ul>
      </section>

      <section id="t7d">
        <h2>Arbeiten mit 3rd-Party-Libs (Beispiel: jquery)</h2>
        <p>
          <a href="code/schritte/5-third-party-jquery/public/index.html" target="_blank">Ziel-Anwendung mit jquery Spinner</a>
        </p>
      </section>

      <section>
        <h2>3rd Party Libs?</h2>
        <div class="fragment">
          <p>Es gibt eine große Anzahl von sehr praktischen JavaScript-Bibliotheken</p>
          <p>Viele davon sind aber nicht als React-Komponenten entwickelt worden</p>
        </div>
        <div class="fragment">
          <p>
            <b>Beispiele</b>
          </p>
          <p>
            <em>jQuery</em> und
            <em>jQuery</em> Plugins wie z.B.
            <em>Bootstrap</em>
          </p>
          <p>
            <em>d3</em> für interaktive SVGs und Chart Bibliotheken wie
            <em>nvd3</em>
          </p>
        </div>
      </section>


      <section>
        <h3>Wo kommen die Libs her</h3>
        <ul>
          <li>Einbinden als JS Datei in index.html (wie in "herkömmlicher" Web Anwendung)</li>
          <li>Installieren als npm Modul (mittlerweile sehr hohe Verbreitung)</li>
        </ul>
      </section>

      <section>
        <h4>Unser Beispiel: Limitieren der Einträge in der Tabelle</h4>
        <a href="code/schritte/5-third-party-jquery/public/index.html" target="_blank">
          <img src="images/master-with-jquery-spinner.png" height="400px">
        </a>
        <h4>Aufgabe: Einbetten des jQuery UI Spinner Widgets in eine React-Komponente</h4>
      </section>
      <section>
        <h3>Ziel: React Spinner Komponente</h3>

        <ul>
          <li class="fragment">Eine React-Komponent, die das jquery UI Spinner Widget kapselt</li>
          <li class="fragment">Für den Verwender soll es transparent sein, dass jQuery verwendet wird (Implementierungsdetail)</li>
          <li class="fragment">Soll sich wie eine "normale" React-Komponente für Verwender verhalten (Properties, Callbacks etc)</li>
        </ul>
        <pre class="fragment"><code data-trim contenteditable class="line-numbers" data-leftpad>
  
  // Beispielhafte Verwendung:          
  &lt;Spinner
    label="Number of Greetings to show"
    value={limitValue}
    onValueChange={newValue => doSomething(newValue)}
  />
        </code></pre>
      </section>

      <section>
        <h3>Hintergrund: jQuery (UI)</h3>
        <ul>
          <li>jQuery ist als globale Funktion
            <code>$</code> definiert</li>
          <li>jQuery benötigt ein DOM Element, auf dem es arbeitet</li>
          <li>Die Funktion erwartet als Parameter u.a. ein DOM Element, auf dem jQuery dann arbeitet</li>
          <li>Der Spinner wird mit
            <code>$(element).spinner()</code> erzeugt
            <ul>
              <li>
                <code>element</code> muss dabei ein HTML
                <code>input</code> Element sein</li>
            </ul>
          </li>
        </ul>
      </section>

      <section>
        <h3>Beispiel: jQuery UI Spinner</h3>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
    &lt;!-- Im HTML Code --&gt;
    &lt;input placeholder="..." id="mySpinner" /&gt;
    
    &lt;!-- JavaScript Code --&gt;
    // Spinner erzeugen
    $("#mySpinner")
      .spinner({
        stop() {
          const newValue = $(this).spinner("value");
          console.log("new sprinner value: ", newValue)
        }
      });
      
    // Einen Wert setzen  
    $("#mySpinner").val(10);
    
                        </code></pre>
      </section>

      <section>
        <h3>Herausforderungen</h3>
        <ol>
          <li class="fragment">Wie kommen wir an den DOM Knoten der React-Komponente?</li>
          <li class="fragment">Wie sagen wir React, dass ab dieses Knotens jQuery für das Rendering zuständig ist? (So dass React nicht mehr neu
            rendert)
          </li>
          </li>
          <li class="fragment">Änderungen des Zustands an der React-Komponente sollen aber nach wie vor richtig dargestellt werden
            <ul>
              <li>
                <code>&lt;Spinner value={newValue} /&gt;</code>
              </li>
            </ul>
          </li>
          <li class="fragment">Wie können wir aus jQuery heraus auch wieder andere React-Komponenten beeinflussen?
            <ul>
              <li>Wert im Spinner ändert sich, also Tabelle neu filtern</li>
            </ul>
          </li>
          <li class="fragment">Wie räumen wir wieder auf?
        </ol>
      </section>

      <section>
        <h3>Erinnerung: React Komponenten Lifecycle</h3>
        <img src="ai/lifecycle-methods-1.png" height="600px" />
      </section>
      <!-- <section>
          <h3>React Lifecycle Methoden</h3>
          <ul>
            <li class="fragment">
              <code><b>componentDidMount()</b></code>: Komponente wurde gerendert, Elemente sind im DOM (einmalig)</li>
            <li class="fragment">
              <code><b>componentWillReceiveProps(nextProps)</b></code>: An die Komponente wurden neue Properties übergeben. Die neuen Properties werden als Parameter übergeben</li>
            <li class="fragment">
              <code><b>shouldComponentUpdate()</b></code>: Entscheidet, ob Komponente erneut gerendert werden soll (default:
              <code>true</code>)</li>
            <li class="fragment">
              <code><b>componentWillUnmount()</b></code>: Wird aufgerufen, bevor Komponente aus dem DOM entfernt wird (einmalig)</li>
          </ul>
  
        </section> -->
      <section>
        <h3>Spinner Komponente #1</h3>
        <p>Erzeugen der jquery Komponente</p>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
  class Spinner extends React.Component {
      render() {
          // render the input and remember the reference to the DOM node
          return &lt;input ref={el => this.spinnerElement = el}>&lt;/input>
      }
  
      // called directly after first render
      componentDidMount() {
        // create the jquery wrapper using the reference saved in render()
        const jquerySpinner = $(this.spinnerElement);
  
        jquerySpinner
          .spinner( /* configuration here */) 
          .val(this.props.value); // set initial value
      }
  
      // ...
  }
         </code></pre>
      </section>
      <section>
        <h3>Spinner Komponente #2</h3>
        <p>Zustandsänderungen nach außen propagieren</p>
        <p>Callback wird per Property an React-Komponente übergeben</p>
        <p>Nach jQuery Event wird Callback aufgerufen</p>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
    class Spinner extends React.Component {
        componentDidMount() {
          // . . .
    
          jquerySpinner
            .spinner({
              stop: () => {
                // "stop" event is fired by jquery after 
                // the spinner value has changed
                const newValue = jquerySpinner.spinner("value");
  
                // run callback function with new value from spinner
                this.props.onValueChange(newValue);
              }
            })
            .val(this.props.value); 
        }
    
        // ...
    }
           </code></pre>
      </section>
      <section>
        <h3>Aktualisieren und Aufräumen</h3>
      </section>

      <section>
        <h3>Lifecycle-Methoden #2</h3>
        <img src="ai/lifecycle-methods-2.png" height="600px" />
      </section>
      <section>
        <h3>Spinner Komponente #3</h3>
        <p>Neu rendern durch React unterbinden</p>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
  class Spinner extends React.Component {
      // ...
  
      // if it returns false, component will not be rendered
      shouldComponentUpdate() {
          // once rendered, React never renders again
          return false;
      }
  
      // ...
  }
         </code></pre>
      </section>

      <section>
        <h3>Spinner Komponente #4</h3>
        <p>Auf Änderungen von außen reagieren</p>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
    class Spinner extends React.Component {
        // ...
    
        // called when React props update 
        // (even when shouldComponentUpdate returned false)
        componentWillReceiveProps(nextProps) {
            // set new value from React props to the spinner 
            $(this.spinnerElement).val(nextProps.value)
        }
    }
           </code></pre>
      </section>

      <section>
        <h3>Spinner Komponente #5</h3>
        <p>Aufräumen sobald Komponente aus dem DOM entfernt wird</p>
        <pre><code data-trim contenteditable class="line-numbers" data-leftpad>
      class Spinner extends React.Component {
          // ...
  
          // called just before destroying component
          componentWillUnmount() {
              $(this.spinnerElement).spinner("destroy")
          }
      }
             </code></pre>
      </section>

      <section>
        <h3>Zusammenfassung #1</h3>
        <ol>
          <li>Wie kommen wir an den DOM Knoten der React-Komponente?
            <ul style="list-style-type: none">
              <li style="margin:0">Über den
                <code>ref</code>-Callback beim rendern der Komponente</code>
              </li>
            </ul>
          </li>
          <li>Wie sagen wir React, dass ab diesem Knoten jQuery für das Rendering zuständig ist? (So dass React nicht mehr neu
            rendert)
            <ul style="list-style-type: none">
              <li style="margin:0">Lifecycle-Methode
                <code>shouldComponentUpdate</code> implementieren</code>
              </li>
            </ul>
          </li>
          <li>Änderungen des Zustands an der React-Komponente sollen aber nach wie vor richtig dargestellt werden
            <ul style="list-style-type: none">
              <li>
                In
                <code>componentWillReceiveProps(nextProps)</code> neue Properties an jQuery Komponente weitergeben
              </li>
            </ul>
          </li>

        </ol>
      </section>

      <section>
        <h3>Zusammenfassung #2</h3>
        <ol start="4">
          <li>Wie können wir aus jQuery heraus auch wieder andere React-Komponenten beeinflussen?
            <ul style="list-style-type: none">
              <li>Auf jQuery Events horchen und dann entsprechende Callback-Funktion aufrufen, die der React Komponente als Property
                übergeben wurde
              </li>
            </ul>
          </li>
          <li>Wie räumen wir wieder auf?
            <ul style="list-style-type: none">
              <li>In der Lifecycle-Methode
                <code>componentWillUnmount</code> kann entsprechender Code ausgeführt werden.
              </li>
            </ul>
        </ol>
      </section>

      <section>
        <h2>Geschafft ;-)</h2>
        <h3>Vielen Dank für Eure Teilnahme!</h3>
        <p>Kontakt: nils@nilshartmann.net</p>
      </section>


    </div>

  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>
  <script src="lib/jquery-2.2.4.js"></script>

  <script>
    Reveal.addEventListener('ready', function (event) {
      if (window.location.hostname.indexOf('localhost') !== -1) {
        // only applies to presentation version
        Reveal.configure({ controls: false });
      } else {
        // only applies to public version
        //            $('.fragment').removeClass('fragment');
      }
      // applies to all versions
      $('code').addClass('line-numbers');
      //        $('.fragment').removeClass('fragment');
    });
  </script>


  <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      width: '100%',
      height: '100%',

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        {
          src: 'reveal.js/lib/js/classList.js', condition: function () {
            return !document.body.classList;
          }
        },
        {
          src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
            return !!document.querySelector('pre code');
          }, callback: function () {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
        { src: 'reveal.js/plugin/notes/notes.js', async: true },
        { src: 'lib/js/line-numbers.js' }
      ]
    });

  </script>

</body>

</html>